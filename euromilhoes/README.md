
Занятие №20. Веб-сайт на Django. Django ORM
Установка Django, использоание ORM, миграции, команды django, подключение страндартной админки.
План: установка Django, создание проекта, настройки, создание приложения, модели, ORM, миграции, запаросы, команды, страндартная админка.
4:00 - создаем новую ветку nu20-orm для 20-го урока
Установка django и виртуального окружения. Джанго это библиотека, очень большая, позволяющая писать сайты, веб приложения любой сложности! Если даже чего-то нехватает, то можно дописать самому, либо воспользоваться множеством сторонних библиотек для любой задачи. Мы будем работать с версией 3.0.3. Установка из settings->Project->interpreter->+->django->Install Package
9:40 - после установки django создаем новый проект в терминале:
django-admin startproject euromilhoes
получаем структуру проекта
далее работать будем командами в терминале и обращаться к файлу manage.py
для этого спускаемся в папку проекта >cd euromilhoes
15:00 - и обращаемся к manage.py - менеджеру запуска
python manage.py runserver
стартует тестовый сервер, как во flask - это очень удобно для быстрой разработки.
Переходим и видим задорную картинку с ракетой: The install worked successfully! Congratulations!
Это первая страничка уже работающего сайта. Там же написано, что мы в режиме разработки: DEBUG=True
16:30 - НАСТРОЙКИ.
У нас сама создалась база данных db.sqlite3 и папка, которая называется так же как проект внутри которой лежат 4 файла:
wsgi.py, asgi.py - это файлы для подключения к вебсерверу, второй асинхронный
urls.py - для прописывания адресов и соответсвующей им вьюхе (во фласке адреса, т.е. пути прописывались в декораторах). 
Там уже прописана стандартная админка по адресу 'admin/'
Сюда мы потом будем прописывать адреса и подключать приложения.
settings.py - настройки проекта. В этом файле есть следуещее:
BASE_DIR - константа, папка, где лежит проект, ведет на корень проекта. Создана, чтобы мы могли при прописывании путей плясать от корня проекта и легко заменить при необходимости.
SECRET_KEY - нужен, чтобы можно было запустить проект и в идеале его потом можно закрыть, чтобы другие не могли ваш проект запустить. Но пока пусть будет.
DEBUG = True - режим разработки, когда мы видим отладочную информацию и можем посмотреть когда, что и где упало.
DEBUG = False - боевой рабочий режим, когда пользователь уже не должен видеть отладочную информацию.
ALLOWED_HOSTS = [] - здесь прописаны доступные хосты, где может быть развернут сайт. Пока пусто.
INSTALLED_APPS - подключенные приложения. Это могу быть любые сторонние или наши приложения, которые совместимы с джанго. Шесть приложений уже подключено: админка, автризация и т.д.
MIDDLEWARE - пока это тайна...
ROOT_URLCONF = 'blog.urls' - прописано, где находится конфигурация адресов
TEMPLATES - настройки шаблонизатора, т.е. где джанго будет искать шаблоны, плюч контекстные процессоры, о чем позже.
WGSI_APPLICATION - путь до приложения, подключающего к веб-серверу
DATABASES - здесь можно подключить различные базы данных. По умолчанию подключена db.sqlite3 на движке sqlite3. И сдесь же указывается логин и пароль для более сложных баз.
AUTH_PASSWORD_VALIDATORS - валидаторы паролей, здесь их 4, но можно самим создавать свои потребные наборы валидаторов.
LANGUAGE_CODE - языковая поддержка. Если поставить ru-ru, то сайт будет на русском. Т.е. очень удобно для перевода прямо налету.
TIME_ZONE = 'UTC' - временная зона
USE_I18N = True - включен перевод
USE_L10N = True - нечто давно забытое...
USE_TZ = True - включена временная зона
STATIC_URL = '/static/' - путь до статики
Чтобы запустить локальный тестовый сервер пишем в терминале python manage.py runserver.
Проекты в джанго обычно разбиты на приложения. Создадим теперь уже приложение внутри нашего проекта и назовем его 
euromilhoesapp. Пишем в терминале python manage.py startapp euromilhoesapp.
(В джанго рекомендуется выделять приложения по модульному принципу, для возможного пере использования в дальнейшем.)
Появляется папочка приложения euromilhoesapp с новыми 5 файлами и __init__.py, обозначающий, что это пакет. 
И папка migrations, в которой тоже есть __init__.py
admin.py - для подключения моделей к админке
apps.py - настройки нашего приложения - не трогаем
models.py - здесь хранятся модели данных, которые относятся к предметной области. Здесь это будет blog, post и category
tests.py - тесты для моделей и вьюшек
views.py -  логика сайта, т.е. вьюшки.


29:20 - ORM и МОДЕЛИ ДАННЫХ
В Джанго есть свой встроенный ORM, поэтому никакая алхимия здесь не нужна. Т.е. работаем не с базой, а с объектами. 
Модели данных создаются практически как во flask
30:47 - открываем файл models.py и там создаем модель - декларативное создание модели.
Т.е. свой класс модели наследуем от Джанговской models.Model - теперь наши объекты (модели) будут отображаться на базу данных, т.е. так подключается функция ORM.
id объявлять не надо - он появится сам.
name = models.CharField(max_length=16, unique=True)
description = model.TextField(blank=True)  // т.е. допускаются пустые поля
33:50 - основные типы полей:
models.CharField - символьный, заданной длины в символах
model.TextField - неограниченной длины
models.DateField
models.DateTimeField
models.TimeField
models.IntegerField
models.PositiveIntegerField
models.PositiveSmallIntegerField
models.FloatField
models.DecimalField
models.BooleanField
models.BinaryField - байты. Им обычно не пользуются, потому что в джанго есть более крутые типы полей:
models.ImageField - это картинка
models.FileField - это файл
models.URLField - это картинка
models.EmailField - это картинка
etc.


37:40 - МИГРАЦИИ
При изменении модели данных мы делаем миграцию и сравниваем: соответствует модель БД или нет. Если не соответствует, 
то создается рецепт как это привести в соответствие и только после этого делается изменение в БД, пока модель не станет соответствовать БД.
39:20 - иллюстрация миграции: сравнение -> рецепт изменений makemigrations -> внесение изменений migrate 
41:50 - миграции в коде. Сперва нужно подключить наше приложение в настройках settings.py в INSTALLED_APPS и добавляем туда прописку для нашего приложения 'blogapp'
Теперь велим джанге сравнить модель и базу и сделал миграцию. В консоли:
blog>python manage.py makemigrations
В папочке migrations добавленного приложения появился файл 0001_initial.py с кодом как делать миграцию. Сюда придется смотреть только в случае ошибок.
Теперь делаем... извините: на-ка-ты-ва-ем миграцию:
blog>python manage.py migrate
47:10 - создаем еще одну модель class Post:(models.Model):
Прописываем поля (свойства)
name  = models.CharField(max_length=16, uniaque=True)   
text = models.TextField()
create = models.DateTimeField(auto_now_add=True)
update = models.DateTimeField(auto_now=True)
50:00 - немного в сторону ответ на вопрос о CMS и Django - пример сайта.
53:40 - типы связей: 1-1, мн-1, 1-мн, мн-мн
Post связан с категорией Category связью либо 1-мн, либо мн-мн
Мы берем вариант 1-мн, т.е. в одной категории может быть много постов. Чтобы это сделать, вы с классе Post делаем связь ForeignKey
53:40 - при указании такой связки джанго предлагает указать что делать, если мы удалим категорию - что тогда делать с постами? И надо указать параметр on_delete=models.CASCADE - т.е. все посты удалятся из категории при ее удалении. Это самый опасный вариант - можно потерять данные.
Здесь мы сразу связываем два объекта: Post и Category, а не как во фласке с relationship и т.д. Теперь у Post есть категория и мы можем получить ее так:
post.category
55:35 - итак добавили модель, в БД ее нет, нужно ее сравнить (makemigrations) и добавить в БД (migrate).
56:50 - вопрос: в классе Category это надо прописывать? Нет. Чего больше, там и прописываем. Постов много, а категория одна, значит только прописываем category в Post
57:50 - добавляем модель class Tag(models.Model):
Прописываем поля (свойства)
Т.к. посты связаны с тегами, то прописываем в Post эту связь. Это связь мн-мн, т.к. может быть много постов с одним тегом и может быть много тегов в посте.
tags = models.ManyToManyField(Tag)
И делаем миграцию. Можно было сделать одну миграцию после всех изменений, а не после каждого.
1:00:00 - ответы на вопросы


1:06:00 - АДМИНКА django
В файле urls.py прописан путь к админке urlspatterns = [path('admin/', admin.site.urls),]
1:07:15 - Введя этот адрес в браузере попадем в админку 127.0.0.1:8000/admin/login/ Но для входа нужен логин-пароль. Для этого нужно создать суперпользователя - администратора.
1:08:00 - создаём суперпользователя >python manage.py createsuperuser
1:09:00 - входим в админку, где есть уже созданные группы и пользователи. Можно добавить группы и пользователей, можно удалить, можно измнить. Но здесь не видно наших созданных моделей. Чтобы их увидеть, их нужно в админку подключить.
1:10:12 - подключение моделей к админке. Для этого в папке приложения в файле admin.py прописываем импорт моделей: from blogapp.models import Category, Post, Tag
а если из того же пакета, то просто с точки: from .models import Category, Post, Tag
1:12:20 - регистрируем модели в админке:
admin.site.register(Category)
admin.site.register(Post)
admin.site.register(Tag)
после этого сервер перезагружается, а если нет, то делаем это вручную и идем в админку, где появились наши модели, где их можно редактировать и эти изменения автоматически сохраняются в БД
1:13:40 - чтобы нормально выводилось название категорий в админке, в модели можно добавить приведение к строке:
def __str__(self):
 return self.name
Это можно настроить и в настройках админки, чтобы не прописывать для каждой модели. Позже.
1:14:55 - самое классное - админка понимает какие нужны типы полей
1:17:00 - сервер можно открыть в одном терминале, а команды набирать в другом - чтобы не останавливать сервер.
1:18:50 - как хранятся логин и пароль в БД.
1:20:00 - Права доступа: статус персонала (просмотр), статус супрепользователя (админ)
1:21:00 - про wsgi - протокол, по котором питон понимает apache, а он питон для их совместрной работы

1:23:00 - работа с даннными. Загрузка в БД. Простые запросы в БД.
Где писать код для добавления данных в БД? а мы добавим свои команды, которые можно будет вызывать через manage.py - менеджер команд.
Как это делать: https://djbook.ru/rel1.8/howto/custom-management-commands.html
Т.е. создаем в приложении пакет management - создаем папку management с файлом __init__.py
Внутри создаем пакет commands
1:27:00 - Внутри создаем питоновский файл со своим скриптом. Т.к. у нас это файл для заполнения БД, то назовем его fill_db.py и копируем в него код с документации
1:28:00 - редактируем код под свои задачи и теперь можем вызывать этот скрипт через manage.py
python manage.py fill_db - выполнится метод handle из fill_db.py
1:34:00 - Как сделать папку корневой
1:30:00 - пишем скрипт fill_db.py
Импортируем модели

ОСНОВНЫЕ ЗАПРОСЫ:
# выбор всех категорий
categories = Category.objects.all() - так получим объект QuerySet
print(categories)
print(type(categories)) - объект класса Category
for item in categories:
 print(item) - объект класса Category
 print(item.name)
 print(type(item))
print('End')

1:37:20 - выбор ОДНОЙ категории:
category = Category.objects.get(name='Игрушки')

1:39:00 - выбор НЕСКОЛЬКИХ категории - вернет не один объект, а QuerySet:
category = Category.objects.filter(name='Игрушки', )

1:41:00 - Как добавить новую команду? Очень просто: создать еще один файл-скрипт.

1:42:00 - Получить первый пост:
post = Post.object.first() - перем первый пост
print(post)
1:43:50 - Связанные поля:
#ForeignKey
print(post.category)
print(type(post.category))
print(post.category.name)
# ManyToMany
print(post.tags.all())
print(post.tags.first())
print(post.tags.first().name)
print(post.tags.filter(name='Один', ))

1:47:00 - как посмотреть свои команды 
>python manage.py
1:49:00 - про related name - подробности позже
1:50:40 - СОЗДАНИЕ данных
Category.objects.create(name='Игрушки', description='Описание категории')
1:52:20 - ИЗМЕНЕНИЕ данных
category = Category.objects.get(name='Игрушки') - получаем объект, чтобы изменить
category.name = 'Игрушки_для_взрослых' - меняем
category.save() - сохраняем

1:53:15 - УДАЛЕНИЕ одной категории
category = Category.objects.get(name='Игрушки_для_взрослых') - получаем объект, чтобы изменить
category.delete() - удаляем. После удаления сохранять ненужно.
1:54:20 - УДАЛЕНИЕ всех категорий
Category.objects.all().delete()
1:59:50 - ДЗ